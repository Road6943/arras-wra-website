<!DOCTYPE html>
<html>

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>

  <body>

    <div id="output"></div>

    <style type="text/css">

      @import url('https://fonts.googleapis.com/css2?family=Ubuntu+Mono&display=swap');

      :root {
        --bgBrown: #cbb690;
        --proofLinkBrown: #795548;
        --hoverBrown: #BAA288;
        --tankColBrown: #9E8171;
        --lightTextColor: #F5DEB3;
      }

      body {
        background-color: var(--bgBrown);
        font-family: Ubuntu Mono, monospace;
      }

      a {
        color: var(--proofLinkBrown);
        font-weight: bold;
      }
      
      table {
        border: 1px solid black;
        border-collapse: collapse;;
      }

      th, td {
        border: 1px solid black;
        padding: 10px;
        text-align: left;
        vertical-align: middle;
        text-align: center;
      }

      th {
        color: var(--lightTextColor);
        border-right: double black;
      }
      /* hide the double border for the leftmost header cell */
      th:first-child {
        border-right-style: none;
      }

      tr:hover {
        text-decoration: underline;
        font-style: italic;
      }

      td:first-child {
        background-color: var(--tankColBrown);
        color: var(--lightTextColor);
      }

      /* select the right border after every record's proof link 
       * to add some visual separation between horizontally adjacent wrs
       */
      td:nth-child(3n + 4) {
        border-right: double;
      }


      #main-header {
        background-color: var(--tankColBrown);
        font-size: 30px;
      }

    </style>

    <script>
      // For the future:
      // currently theres bugs, like empty records causing existing ones of the same row to slide left and end up in the wrong column
      // also theres no protection against people whose sheet names are identical to an existing tank or gamemode, or whose names include valid js code
      // to fix this:
      // make a new tab of the spreadsheet, and fill it with data from the Records sheet but formatted the way I want
      // This way, I don't have to filter out gamemode names or do special stuff for tank names
      // I can just dump tank names into the first column and use it directly, plus add image urls into the 0th column and make image objects from them
      // also, I can add &#&#& or some other rarer symbol using apps script to indicate empty records, and filter them out in this script
      // plus I can add newline characters after each row, to more easily figure out when to make a new table row
      // also get a js library to make stick table headers/cols so that the tank/gamemode is always visible when scrolling through the records


      // when sheet is updated, here's what you need to do:
      // change the url's ?range= to cover the entirety of the new records, from tank column to last row of last gamemode column
      // add the gamemode to gamemodes, along with its color
      // add the tank to tanks, the same way it appears on the sheet
      const CONSTANTS = {
      url: 'https://spreadsheets.google.com/feeds/cells/1HDQtELScci0UlVR4ESnvhM6V8bgAtNX8GI3pzq7cG8M/2/public/basic?range=B16:AF121&alt=json',
      
      numGamemodes: 10,
      
      gamemodes: {"FFA": "#E24E36", "Maze": "#FD9827", "2TDM": "#117BA5", "Maze 2TDM": "#0294C1", "4TDM": "#846187", "Maze 4TDM": "#A44E78", "Open Maze 4TDM": "#352073", "Domination (All)": "#FA8072", "Mothership (All)": "#DC71A1", "Open 3/4 TDM": "#689168"},

      tanks: ["(Basic) Tank", "Director", "Flank Guard", "Machine Gun", "Pounder", "Sniper", "Trapper", "Twin", "Artillery", "Assassin", "Auto 3", "Builder", "Cruiser", "Destroyer", "Double Twin", "Gunner", "Hexa Tank", "Hunter", "Minigun", "Overseer", "Rifle", "Smasher", "Spawner", "Trap Guard", "Tri-Angle", "Triple Shot", "Tri-Trapper", "Underseer", "Annihilator", "Architect", "Auto-4", "Auto-5", "Auto Assassin", "Auto Builder", "Auto Double", "Auto Gunner", "Auto Overseer", "Auto Smasher", "Auto Spawner", "Auto Tri-Angle", "Banshee", "Barricade", "Battleship", "Bent Double", "Bent Hybrid", "Bomber", "Boomer", "Booster", "Bulwark", "Bushwhacker", "Carrier", "Conqueror", "Constructor", "Crop Duster", "Cyclone", "Dual", "Eagle", "Engineer", "Factory", "Falcon", "Fighter", "Fortress", "Gunner Trapper", "Hexa Trapper", "Hewn Double", "Hybrid", "Landmine", "Machine Gunner", "Maleficitor", "Manager", "Mega Smasher", "Mega-3", "Mortar", "Musket", "Nailgun", "Necromancer", "Octo Tank", "Overdrive", "Overgunner", "Overlord", "Overtrapper", "Penta Shot", "Poacher", "Predator", "Ranger", "Septa Trapper", "Shotgun", "Sidewinder", "Single", "Skimmer", "Spike", "Sprayer", "Spreadshot", "Stalker", "Streamliner", "Surfer", "Swarmer", "Triple Twin", "Triplet", "Twister",],
    };


    getData()
      .then(data => printTable(data));


    async function getData() 
    {  
      let response = await fetch(CONSTANTS.url);
      
      let data = await response.json();
      
      // look at the json returned in order to make sense of the stuff below:
      data = data.feed.entry
               .map(item => item.content.$t)
               /* removes the gamemode name cells */
               .filter(item => !( Object.keys(CONSTANTS.gamemodes) ).includes(item));
      
      console.log(data);
      
      return data;
    }


    async function printTable(data)
    {
      let numItems = 0;
      let bgColor = "var(--bgBrown)";
      let outputHTML = "<table>";

      // add large title header
      outputHTML += `<th colspan="${(CONSTANTS.numGamemodes * 3) + 1}" id="main-header">Arras.io World Records Archive</th>`;


      // add gamemode headers
      outputHTML += `<tr><th></th>`;

      for (gamemode in CONSTANTS.gamemodes)
      {
        outputHTML += `<th colspan="3" style="background-color: ${CONSTANTS.gamemodes[gamemode]}">${gamemode}</th>`;
      }

      outputHTML += `</tr>`;


      // everything else
      for await (let item of data)
      {
        if (CONSTANTS.tanks.includes(item))
        {
          outputHTML += `</tr><tr><td>${item}</td>`;
          continue;
        }

        
        switch (numItems++ % 3) 
        {
          // score
          case 0:
            // update the bgColor whenever a new score appears
            // then reuse color for name and proofLink, until a new score appears
            bgColor = getScoreColor(item);

          // name
          // note that score falls through to use this html as well
          case 1:
            outputHTML += `<td style="background-color: ${bgColor}">${item}</td>`;
            break;
            
          // proof link
          case 2:
            outputHTML += `<td style="background-color: ${bgColor}"><a href="${item}">Proof</a></td>`;
            break;
        }
      }

      outputHTML += `</table>`;

      document.querySelector("#output").innerHTML = outputHTML;
    }



    function getScoreColor(score)
    {

      // anything under 1 mil doesn't get a colored background
      // aka, 123.45k has score[6] as k, so it returns early 
      // with the default bg color
      if (score[6] === 'k') return "var(--bgBrown)";


      // get the first 4 characters (1.23mil -> 1.23)
      score = score.slice(0,4);
      score = parseFloat(score);


      if      (score >= 7.50) return "#91CBD6";
      else if (score >= 6.00) return "#FFA346";
      else if (score >= 5.00) return "#EAE0C9";
      else if (score >= 4.00) return "#649BD0";
      else if (score >= 3.50) return "#AD93C1";
      else if (score >= 3.00) return "#95C378";
      else if (score >= 2.50) return "#DF7D73";
      else if (score >= 2.00) return "#FOC143";
      else if (score >= 1.50) return "#989B9D";
      else if (score >= 1.00) return "#CFA087";
    }

    </script>

  </body>

</html>
