<!DOCTYPE html>
<html>

  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>

  <body>

    <div id="output"></div>

    <style type="text/css">

      @import url('https://fonts.googleapis.com/css2?family=Ubuntu+Mono&display=swap');

      :root {
        --bgBrown: #cbb690;
        --proofLinkBrown: #795548;
        --hoverBrown: #BAA288;
        --tankColBrown: #9E8171;
        --lightTextColor: #F5DEB3;
      }

      body {
        background-color: var(--bgBrown);
        font-family: Ubuntu Mono, monospace;
      }
      
      table {
        border: 1px solid black;
        border-collapse: collapse;;
      }

      th, td {
        border: 1px solid black;
        padding: 10px;
        text-align: left;
        vertical-align: middle;
        text-align: center;
      }

      th {
        color: var(--lightTextColor);
        border-right: double black;
      }
      /* hide the double border for the leftmost header cell */
      th:first-child {
        border-right-style: none;
      }


      td:first-child, td:nth-child(2) {
        background-color: var(--tankColBrown);
        color: var(--lightTextColor);
      }

      /* make the score (1st line) bold by causing playerName to flow into 2nd line no matter what*/
      a {
        white-space: pre-line;
        color: black;
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
        font-style: italic;
        color: var(--proofLinkBrown);
      }

      #main-header {
        background-color: var(--tankColBrown);
        font-size: 30px;
      }

    </style>

    <script>
      // For the future:
      // currently theres bugs, like empty records causing existing ones of the same row to slide left and end up in the wrong column
      // also theres no protection against people whose sheet names are identical to an existing tank or gamemode, or whose names include valid js code
      // to fix this:
      // make a new tab of the spreadsheet, and fill it with data from the Records sheet but formatted the way I want
      // This way, I don't have to filter out gamemode names or do special stuff for tank names
      // I can just dump tank names into the first column and use it directly, plus add image urls into the 0th column and make image objects from them
      // also, I can add &#&#& or some other rarer symbol using apps script to indicate empty records, and filter them out in this script
      // plus I can add newline characters after each row, to more easily figure out when to make a new table row
      // also get a js library to make stick table headers/cols so that the tank/gamemode is always visible when scrolling through the records

      // NEW IDEA: read this: https://stackoverflow.com/a/33727897
      // use this JSON feed for records: https://docs.google.com/spreadsheets/d/1HDQtELScci0UlVR4ESnvhM6V8bgAtNX8GI3pzq7cG8M/gviz/tq?tqx=out:json&sheet=Records
      // its preformatted into rows and cols, and includes null values for empty cells!!!
      // important note: you need to remove the ); at the end and the googleservice...( at the beginning
      // I think a simple split or something should be enough to do that
      // also note that the url supports querying, so I can use query commands directly through the url from New_Calculations for the P/T stats page
      

      // when sheet is updated, here's what you need to do:
      // change the url's ?range= to cover the entirety of the new records, from tank column to last row of last gamemode column
      // add the gamemode to gamemodes, along with its color
      // add the tank to tanks, the same way it appears on the sheet
      const CONSTANTS = {
      url: 'https://spreadsheets.google.com/feeds/cells/1HDQtELScci0UlVR4ESnvhM6V8bgAtNX8GI3pzq7cG8M/1/public/basic?range=F5:H5&alt=json',
      
      numGamemodes: 10,
      
      gamemodes: {"FFA": "#E24E36", "Maze": "#FD9827", "2TDM": "#117BA5", "Maze 2TDM": "#0294C1", "4TDM": "#846187", "Maze 4TDM": "#A44E78", "Open Maze 4TDM": "#352073", "Domination (All)": "#FA8072", "Mothership (All)": "#DC71A1", "Open 3/4 TDM": "#689168"},

      tanks: ["(Basic) Tank", "Director", "Flank Guard", "Machine Gun", "Pounder", "Sniper", "Trapper", "Twin", "Artillery", "Assassin", "Auto 3", "Builder", "Cruiser", "Destroyer", "Double Twin", "Gunner", "Hexa Tank", "Hunter", "Minigun", "Overseer", "Rifle", "Smasher", "Spawner", "Trap Guard", "Tri-Angle", "Triple Shot", "Tri-Trapper", "Underseer", "Annihilator", "Architect", "Auto-4", "Auto-5", "Auto Assassin", "Auto Builder", "Auto Double", "Auto Gunner", "Auto Overseer", "Auto Smasher", "Auto Spawner", "Auto Tri-Angle", "Banshee", "Barricade", "Battleship", "Bent Double", "Bent Hybrid", "Bomber", "Boomer", "Booster", "Bulwark", "Bushwhacker", "Carrier", "Conqueror", "Constructor", "Crop Duster", "Cyclone", "Dual", "Eagle", "Engineer", "Factory", "Falcon", "Fighter", "Fortress", "Gunner Trapper", "Hexa Trapper", "Hewn Double", "Hybrid", "Landmine", "Machine Gunner", "Maleficitor", "Manager", "Mega Smasher", "Mega-3", "Mortar", "Musket", "Nailgun", "Necromancer", "Octo Tank", "Overdrive", "Overgunner", "Overlord", "Overtrapper", "Penta Shot", "Poacher", "Predator", "Ranger", "Septa Trapper", "Shotgun", "Sidewinder", "Single", "Skimmer", "Spike", "Sprayer", "Spreadshot", "Stalker", "Streamliner", "Surfer", "Swarmer", "Triple Twin", "Triplet", "Twister",],
    
    };


    getData()
      //.then(data => printTable(data));
      .then(data => makeTable(data));


    async function getData() 
    {  
      let response = await fetch(CONSTANTS.url);
      let data = await response.json();
      
      data = data.feed.entry
               .map(item => item.content.$t) // look at the json returned in order to make sense of this stuff
               .join("") // sheets has max char limit per cell, so this recombines the split up data into one giant string again
               .slice(2, -2) // remove the [[ at the beginning and ]] at the end
               .split("],[") // make each sheet row into an array row
               .map(row => row.split(",")) // split each array row into another array, representing each cell in that row
               .map(row => row.map(cell => // JSON returns extra "" around every string, so this removes them and also converts the score cells into ints
                  cell.includes(`"`) ? cell.slice(1,-1) : parseInt(cell, 10) 
                )) 
               ;

      console.log(data);
      
      return data;
    }


    function makeTable(data)
    {
      let table = document.createElement("table");

      for (const dataRow of data)
      {
        const tableRow = document.createElement("tr");

        // create cells for the tankPic and tankName cols
        const tankPic = document.createElement("td");
        tankPic.textContent = (dataRow[0] !== "") ? dataRow[0] : ""; // JSON returns \"\" instead of actual emptiness
        tableRow.appendChild(tankPic);

        const tankName = document.createElement("td");
        tankName.textContent = (dataRow[1] !== "") ? dataRow[1] : ""; // JSON returns \"\" instead of actual emptiness, also json wraps everything in extra ""
        tableRow.appendChild(tankName);


        // start at 2 since tank/tankPic col, theres 3 cells per record (score/name/proofLink)
        for (let col = 2; col < dataRow.length; col += 3)
        {
          const tableCell = document.createElement("td");

          // empty proofLink means theres no record there yet
          // attach empty cell, and continue
          const proofLink = dataRow[col + 2];
          if (proofLink === "")
          {
            tableRow.appendChild(tableCell);
            continue;
          }

          const score = formatNumber(dataRow[col]);
          const playerName = dataRow[col + 1];

          // make a link, and set it to open in new window, and prevent window.open malicious stuff
          const link = document.createElement("a");
          link.setAttribute("href", proofLink);
          link.setAttribute("target", "_blank");
          link.setAttribute("rel", "noopener");
          
          // add playerName like this instead of using innerHTML to prevent XSS injection
          link.textContent = playerName;

          // add bolded score and then linebreak right before the playerName
          link.insertAdjacentHTML("afterbegin", `<strong>${score}</strong><br/>`);

          // make bg color based on the score
          tableCell.style.backgroundColor = getScoreColor(score);

          tableCell.appendChild(link);
          tableRow.appendChild(tableCell);
        }

        table.appendChild(tableRow);
      }

      document.querySelector("body").appendChild(table);
    }


    


    // passed in as a string like 123.45k or 1.23mil
    function getScoreColor(score)
    {
      // anything under 1 mil doesn't get a colored background
      // aka, 123.45k has score[6] as k, so it returns early 
      // with the default bg color
      if (score[6] === 'k') return "var(--bgBrown)";

      // get the first 4 characters (1.23mil -> 1.23)
      score = score.slice(0,4);
      score = parseFloat(score);

      if      (score >= 7.50) return "#91CBD6";
      else if (score >= 6.00) return "#FFA346";
      else if (score >= 5.00) return "#EAE0C9";
      else if (score >= 4.00) return "#649BD0";
      else if (score >= 3.50) return "#AD93C1";
      else if (score >= 3.00) return "#95C378";
      else if (score >= 2.50) return "#DF7D73";
      else if (score >= 2.00) return "#F0C143";
      else if (score >= 1.50) return "#989B9D";
      else if (score >= 1.00) return "#CFA087";
    }


    // 1234567 -> 1.23mil, 123456 -> 123.46k
    function formatNumber(score)
    {
      if (score >= 10**6) 
      {
        return (score / 10**6).toFixed(2) + "mil";
      }
      else 
      {
        return (score / 1000).toFixed(2) + "k";
      }
    }

    </script>

  </body>

</html>
